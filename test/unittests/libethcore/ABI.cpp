/**
 * @CopyRight:
 * FISCO-BCOS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FISCO-BCOS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FISCO-BCOS.  If not, see <http://www.gnu.org/licenses/>
 * (c) 2016-2018 fisco-dev contributors.
 *
 * @brief
 *
 * @file ABI.cpp
 * @author: jimmyshi
 * @date 2018-09-02
 */
#include <iostream>

#include <libethcore/ABI.h>
#include <test/tools/libutils/TestOutputHelper.h>
#include <boost/test/unit_test.hpp>
#include <string>

using namespace std;
using namespace dev;
using namespace dev::eth;
using namespace dev::test;
namespace ut = boost::unit_test;

namespace dev
{
namespace test
{
BOOST_FIXTURE_TEST_SUITE(ABITest, TestOutputHelperFixture)

BOOST_AUTO_TEST_CASE(ContractABIType_u256)
{
    ContractABI ct;

    u256 x = 0;
    std::string r = toHex(ct.serialise(x));
    BOOST_CHECK(r == "0000000000000000000000000000000000000000000000000000000000000000");

    u256 y("0x7fffffffffffffff");
    r = toHex(ct.serialise(y));
    BOOST_CHECK(r == "0000000000000000000000000000000000000000000000007fffffffffffffff");

    u256 z("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    r = toHex(ct.serialise(z));
    BOOST_CHECK(r == "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

    u256 u("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe");
    r = toHex(ct.serialise(u));
    BOOST_CHECK(r == "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe");
}

BOOST_AUTO_TEST_CASE(ContractABIType_s256)
{
    ContractABI ct;

    s256 x = 0;
    std::string r = toHex(ct.serialise(x));
    BOOST_CHECK_EQUAL(r, "0000000000000000000000000000000000000000000000000000000000000000");

    s256 y("0x7fffffffffffffff");
    r = toHex(ct.serialise(y));
    BOOST_CHECK_EQUAL(r, "0000000000000000000000000000000000000000000000007fffffffffffffff");

    s256 z = -1;
    r = toHex(ct.serialise(z));
    BOOST_CHECK_EQUAL(r, "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

    s256 s = 1000;
    r = toHex(ct.serialise(s));
    BOOST_CHECK_EQUAL(r, "00000000000000000000000000000000000000000000000000000000000003e8");
}

BOOST_AUTO_TEST_CASE(ContractABIType_bool)
{
    ContractABI ct;

    bool x = true;
    std::string r = toHex(ct.serialise(x));
    BOOST_CHECK_EQUAL(r, "0000000000000000000000000000000000000000000000000000000000000001");


    bool y = false;
    r = toHex(ct.serialise(y));
    BOOST_CHECK_EQUAL(r, "0000000000000000000000000000000000000000000000000000000000000000");
}

BOOST_AUTO_TEST_CASE(ContractABIType_addr)
{
    ContractABI ct;

    Address x;
    std::string r = toHex(ct.serialise(x));
    BOOST_CHECK_EQUAL(r, "0000000000000000000000000000000000000000000000000000000000000000");


    Address y("0xbe5422d15f39373eb0a97ff8c10fbd0e40e29338");
    r = toHex(ct.serialise(y));
    BOOST_CHECK_EQUAL(r, "000000000000000000000000be5422d15f39373eb0a97ff8c10fbd0e40e29338");
}

BOOST_AUTO_TEST_CASE(ContractABIType_string)
{
    ContractABI ct;

    std::string x("Hello, world!");
    std::string r = toHex(ct.serialise(x));
    BOOST_CHECK_EQUAL(
        r, std::string("000000000000000000000000000000000000000000000000000000000000000d48656c6c6"
                       "f2c20776f726c642100000000000000000000000000000000000000"));

    std::string y("");
    r = toHex(ct.serialise(y));
    BOOST_CHECK_EQUAL(
        r, std::string("0000000000000000000000000000000000000000000000000000000000000000"));
}

BOOST_AUTO_TEST_CASE(ContractABIType_array_uint256)
{
    ContractABI ct;

    std::array<u256, 3> x{1, 2, 3};
    std::string r = toHex(ct.serialise(x));
    BOOST_CHECK_EQUAL(
        r, std::string("00000000000000000000000000000000000000000000000000000000000000010"
                       "0000000000000000000000000"
                       "00000000000000000000000000000000000002000000000000000000000000000"
                       "0000000000000000000000000"
                       "000000000003"));

    std::vector<u256> y{1, 2, 3};
    r = toHex(ct.serialise(y));
    BOOST_CHECK_EQUAL(
        r, std::string("000000000000000000000000000000000000000000000000000000000000000300000000000"
                       "000000000000000"
                       "0000000000000000000000000000000000000100000000000000000000000000"
                       "000000000000000000000000000000000000020000000000000000000000000000000000000"
                       "000000000000000"
                       "000000000003"));
}

BOOST_AUTO_TEST_CASE(ContractABITest0)
{
    ContractABI ct;

    u256 a = 12345;
    s256 b = -67890;
    string c("xxxsxxxsxxs");
    string32 d = toString32(std::string("adsggsakjffl;kajsdf"));

    auto r = ct.abiInHex("", a, b, c, d);

    u256 outA;
    s256 outB;
    string outC;
    string32 outD;

    bool Ok = ct.abiOutHex(r, outA, outB, outC, outD);
    BOOST_CHECK(Ok == true);
    BOOST_CHECK(a == outA);
    BOOST_CHECK(b == outB);
    BOOST_CHECK(c == outC);
    BOOST_CHECK(d == outD);
}

BOOST_AUTO_TEST_CASE(ContractABITest1)
{
    u256 a = 100;
    s256 b = -100;
    std::string c = "abc";
    std::vector<std::string> d = {"abc", "abc", "abc"};
    std::array<std::string, 3> e{"abc", "abc", "abc"};

    std::string expect =
        "0000000000000000000000000000000000000000000000000000000000000064ffffffffffffffffffffffffff"
        "ffffffffffffffffffffffffffffffffffff9c0000000000000000000000000000000000000000000000000000"
        "0000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000"
        "000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000"
        "000000000000000000000003616263000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000"
        "000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000"
        "00000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000"
        "000000000000000000000000000000000000000000000003616263000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000000000000000000000000036162"
        "630000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000361626300000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000"
        "00000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000"
        "000000000000000000e00000000000000000000000000000000000000000000000000000000000000003616263"
        "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000036162630000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000000000361626300000000000000"
        "00000000000000000000000000000000000000000000";

    ContractABI ct;
    auto r = ct.abiInHex("", a, b, c, d, e);
    BOOST_CHECK_EQUAL(r, expect);

    u256 outA;
    s256 outB;
    std::string outC;
    std::vector<std::string> outD;
    std::array<std::string, 3> outE;

    bool Ok = ct.abiOutHex(r, outA, outB, outC, outD, outE);

    BOOST_CHECK_EQUAL(Ok, true);
    BOOST_CHECK(a == outA);
    BOOST_CHECK(b == outB);
    BOOST_CHECK(c == outC);
    BOOST_CHECK(d == outD);
    BOOST_CHECK(e == outE);
}

BOOST_AUTO_TEST_CASE(ContractABITest2)
{
    std::array<std::vector<u256>, 3> a{
        std::vector<u256>{1}, std::vector<u256>{2, 3}, std::vector<u256>{4, 5, 6}};

    std::string expect =
        "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000"
        "000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000"
        "0000000000a0000000000000000000000000000000000000000000000000000000000000010000000000000000"
        "000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000"
        "000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200"
        "000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000"
        "000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000"
        "000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000"
        "000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000"
        "0000000000000000000006";

    ContractABI ct;
    auto r = ct.abiInHex("", a);
    BOOST_CHECK(r == expect);

    std::array<std::vector<u256>, 3> outA;
    bool Ok = ct.abiOutHex(r, outA);

    BOOST_CHECK_EQUAL(Ok, true);
    BOOST_CHECK(a == outA);
}

BOOST_AUTO_TEST_CASE(ContractABITest3)
{
    ContractABI ct;
    u256 a = 123;
    Address b("0x692a70d2e424a56d2c6c27aa97d1a86395877b3a");
    std::string c = "string c";
    std::vector<u256> d{1, 2, 3};
    std::array<u256, 3> e = {4, 5, 6};

    std::vector<std::string> f{"abc", "def", "ghi"};
    std::array<std::string, 3> g{"abc", "def", "ghi"};

    std::vector<std::vector<u256>> h{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}};
    std::vector<std::array<u256, 3>> i{{4, 4, 4}, {5, 5, 5}};

    auto r = ct.abiInHex("", a, b, c, d, e, f, g, h, i);

    std::string expect =
        "000000000000000000000000000000000000000000000000000000000000007b00000000000000000000000069"
        "2a70d2e424a56d2c6c27aa97d1a86395877b3a0000000000000000000000000000000000000000000000000000"
        "00000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000"
        "000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000"
        "000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600"
        "000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000"
        "000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000"
        "000000048000000000000000000000000000000000000000000000000000000000000006800000000000000000"
        "000000000000000000000000000000000000000000000008737472696e67206300000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000"
        "000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000"
        "000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000"
        "000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000"
        "000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000"
        "000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000"
        "000000000000000000000000000000000000000000000000000000000361626300000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        "000003646566000000000000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000036768690000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000"
        "000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000"
        "0000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000"
        "000361626300000000000000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000003646566000000000000000000000000000000000000000000"
        "000000000000000000000000000000000000000000000000000000000000000000000000000000036768690000"
        "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        "000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000"
        "6000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000"
        "000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000"
        "000000000000030000000000000000000000000000000000000000000000000000000000000001000000000000"
        "000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000"
        "000000000000000000000000010000000000000000000000000000000000000000000000000000000000000003"
        "000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000"
        "000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000"
        "000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000"
        "000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000"
        "000000000000000000000003000000000000000000000000000000000000000000000000000000000000000300"
        "000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000"
        "000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000"
        "000000000400000000000000000000000000000000000000000000000000000000000000040000000000000000"
        "000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000"
        "00000000000000000000050000000000000000000000000000000000000000000000000000000000000005";


    BOOST_CHECK_EQUAL(r, expect);

    u256 outA;
    Address outB;
    std::string outC;
    std::vector<u256> outD;
    std::array<u256, 3> outE;

    std::vector<std::string> outF;
    std::array<std::string, 3> outG;

    std::vector<std::vector<u256>> outH;
    std::vector<std::array<u256, 3>> outI;
    bool Ok = ct.abiOutHex(r, outA, outB, outC, outD, outE, outF, outG, outH, outI);

    BOOST_CHECK(Ok == true);
    BOOST_CHECK(a == outA);
    BOOST_CHECK(b == outB);
    BOOST_CHECK(c == outC);
    BOOST_CHECK(d == outD);
    BOOST_CHECK(e == outE);
    BOOST_CHECK(f == outF);
    BOOST_CHECK(g == outG);
    BOOST_CHECK(h == outH);
    BOOST_CHECK(i == outI);
}

BOOST_AUTO_TEST_SUITE_END()
}  // namespace test
}  // namespace dev